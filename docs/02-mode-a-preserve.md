<!-- docs/02-mode-a-preserve.md -->
# 模式 A：保留订阅原始 group/rules（原理与实现细节）

← [返回 README](../README.md)  
→ 下一篇：[模式 B：统一 ACL4SSR](03-mode-b-acl4ssr.md)

> 模式 A 适合：订阅自带 proxy-groups 很复杂（地区组/媒体组/Telegram 组/自动测速组等），你希望尽量保留原结构，只做必要的“命名空间化”和“provider 化改写”。

---

## 1) 模式 A 做了什么（概览）

对每个订阅（命名空间为 `ns`）：

1. 远程订阅：生成 `proxy-providers.ns`
2. 给订阅中的所有 group / proxy 名做命名空间：`ns/<原名>`
3. **新增一个默认组：`ns/默认`**
4. 对订阅自带的 `proxy-groups` 做“叶子/非叶子”重写（下面详解）
5. 订阅自带 `rules` 进入 `sub-rules.rules_ns`，并让该端口 listener 绑定 `rule: rules_ns`
6. 所有订阅的 `ns/默认` 聚合进 `ALL/默认`（用于默认端口或统一出口）

---

## 2) 为什么必须新增 `ns/默认`

核心原因：如果group中不完全是proxies节点，如果是group那么在使用use的时候无法保留，使用默认组来替代这些被删除的proxies，但该策略也不是完美

### `ns/默认` 是什么？
每个订阅新增一个组：`ns/默认`

- **远程订阅（有 provider）**：`ns/默认` 使用 `use: [ns]`
  - 表示：这个组的候选节点来自 provider `ns` 的全部节点（自动更新）
- **local（无 provider）**：`ns/默认` 使用 `proxies: [ns/节点1, ns/节点2, ...]`

### 它解决了两个关键问题
1. **兜底出口**：当某些 group 被我们“删掉节点枚举”后，仍然要提供一个可选的真实节点入口
2. **聚合出口**：`ALL/默认` 需要一个“每订阅的代表性出口”才能把多个订阅汇总

---

## 3) 叶子组 vs 非叶子组（核心）

> 订阅里的 proxy-groups 通常是一个树：上层组引用下层组，下层组包含具体节点。
> 我们把 group 分成两类：

### 3.1 叶子组（Leaf Group）
判定：组内 `proxies` **不引用任何其它 group**（只包含节点名和/或 BUILTIN，如 DIRECT/REJECT/PASS）。

典型例子：
- `🇯🇵 日本组` 里全是 `日本01/日本02/...`
- `自动选择` 里全是节点名
- `url-test` / `fallback` 的 proxies 里全是节点

**叶子组在 provider 场景下的问题：**
- provider 会更新节点列表，节点名字可能变化
- 如果你把叶子组的节点名“写死”在 `proxies:` 列表里，后续更新就会出现：
  - 节点不存在 / 名字对不上 / 组失效

**因此：远程订阅的叶子组会被“provider 化”：**
- 删除组内显式列出的节点名（避免写死）
- 改成 `use: [ns]`（让节点来自 provider）
-（可选）再通过 `filter / exclude-filter` 控制该组筛选规则（如果你脚本支持）

> local 订阅无法 use provider，因此 local 的叶子组一般保持 `proxies:`（或者你另行实现 local 的 filter 机制）。

### 3.2 非叶子组（Non-leaf Group）
判定：组内 `proxies` **包含对其它 group 的引用**（例如 `proxies: [Auto, 香港组, 日本组, …, 日本01, 日本02]`）

典型例子：
- 顶层 “节点选择” 同时引用 `自动选择/地区组`，还枚举了一堆节点
- “漏网之鱼”引用上层组，也列了一堆节点

---

## 4) 非叶子节点删除原理（你提到的核心点）

### 4.1 为什么要“删除非叶子组里枚举的节点”
非叶子组里往往混了两类条目：
1) 其它组名（引用子组）  
2) 一堆具体节点名（枚举）

对于 **远程 provider 订阅**，第 2 类“节点枚举”最危险：
- provider 更新后，节点名可能变化
- 非叶子组里写死的节点会逐渐失效
- 同时，节点枚举会让顶层组变得巨大且难维护（每个订阅都不一样）

因此我们对非叶子组做一个“瘦身 + 可更新”重写：

### 4.2 删除规则（非叶子组重写逻辑）
对非叶子组的 `proxies` 列表逐项处理：

- **保留**：
  - BUILTIN：`DIRECT / REJECT / PASS`
  - 对其它 group 的引用（会被命名空间化为 `ns/<group>`）
- **丢弃**：
  - 具体节点名（以及无法判定的“非 group 引用项”）

### 4.3 关键补丁：把 `ns/默认` 塞回非叶子组（避免入口丢失）
删掉节点枚举后，非叶子组可能只剩“子组引用 + BUILTIN”。
为了保证顶层选择器仍然能直接选到“这个订阅的全部节点”，我们会：

- **只要非叶子组发生过“删除节点枚举”**，就把 `ns/默认` 插入到该组的 `proxies` 里（通常放在最前）

这样顶层组至少包含：
- `ns/默认`（订阅全部节点入口）
- 原有子组引用（结构不丢）
- DIRECT/REJECT（如原来就有）

---

## 5) 模式 A 的最终效果（你会在 UI 看到什么）

- 原订阅的 group 树结构仍在（但已改名为 `ns/...`）
- 顶层组不会再塞满“过时的节点枚举”
- 每个订阅都有 `ns/默认` 可作为“该订阅出口”
- `ALL/默认` 聚合各订阅默认组，可作为全局默认端口出口

---

## 6) 常见误解澄清

### “删了节点枚举，是不是丢失了订阅自带分组？”
不会。我们保留了 group 引用关系（树结构），只是删掉了非叶节点里“写死的节点列表”，避免 provider 更新后失效。

### “为什么不把所有组都改成 use？”
非叶子组本质是“组的组合”，如果对非叶子也 use，会破坏原来的组引用结构（并让逻辑变得不可控）。因此：
- 叶子组：适合用 use（节点来源）
- 非叶子组：适合保留组引用（结构），只补 `ns/默认` 做入口

---

下一篇：
→ [模式 B：统一 ACL4SSR（订阅前缀 ns/…）](03-mode-b-acl4ssr.md)
